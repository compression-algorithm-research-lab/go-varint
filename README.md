# VarInt（变长整数）的Go实现 

# 一、这是什么？解决了啥问题？

这是一个可变长`int`的数据类型实现，类似于数据库中的`varchar`类型，我们都知道，当要把`int`存储在硬盘上或者在内存中存储时，正常情况下`int`是要存储为多个字节的，比如`int64`，需要`8`个字节，比如`int32`，需要`4`个字节，假设我们使用`int64`来存储`1`这个数字，把这个`int64`的这`8`个字节展开为每一个`bit`大概是这个样子：

![image-20221201004517168](README.assets/image-20221201004517168.png)

可以看到，虽然`int64`有`64`位，但是实际上只使用了一个`bit`位（暂不考虑符号位），这意味着有效使用位只有一个`bit`，其它的`63`个`bit`都浪费了，`varint`就是想着尽可能的提高表示整数时的`bit`的利用率减少浪费，整数不再使用固定长度的字节数表示，而是需要几个字节就使用几个字节，类似于数据库中的`varchar`类型，但是这样怎么知道究竟使用了几个字节呢，于是就把`byte`的最高的一个`bit`拿出来作为标记位，如果为`1`则表示后续后续的一个字节还是表示的这个数字，如果为`0`则表示这个数字已经结束，比如数字`1024`，则表示为：

![image-20221201005133305](README.assets/image-20221201005133305.png)

这样子只需要两个字节就可以了，每个字节的最高位就叫做最高有效位（the Most Significant Bit）。

## 什么样子的数据适合使用VarInt 

值的分布范围很大，并且绝大多数的值都分布在较小的那边，比如现在有一百亿个数字，其中有`99`亿个数字都是分布在`[0, 2^7]`的区间，而剩下的`1`亿个数字随机分布在`[2^8m, 2^31]`这个区间，对于这种类型的数，直接使用偏移收缩不合适，直接使用较小的数据类型不合适大的放不下了，而`[0, 2^7]`这个区间上的数组都可以压缩为一个字节的`varint`表示形式，所以分布式在`[0, 2^7]`的这`99`亿个数字都可以被压缩，这种情况的压缩效率就比较高，那么就是用`varint`类型，使得绝大多数数据都能消耗较小的空间，并且部分有需要的仍然使用较大的空间。



## 大端还是小端









## varint真的不能存储有符号的整数吗



我在VarInt的基础上进行了一个扩展，因为我发现最高位的字节在大多数的情况下是存不满的，所以我打算将大端所在的

一个更好的思路是将有符号类型映射到无符号类型，

```
https://github.com/compression-algorithm-research-lab/go-zigzag
```



TODO 比较两种方式的差距，扩展的varint的压缩效率是不如zigzag的





## 应用场景

- 存储无符号整数时节省空间
- 内存计算节省空间，支持更大规模的计算量（时间换空间） 

# 二、添加依赖

```bash
go get -u github.com/compression-algorithm-research-lab/go-varint
```

# 四、VarInt & VarUint API

此库定义了一个`VarInt`数据类型，提供了一些`API`，用于在`VarInt`类型之间进行一些算数操作，`VarInt`本质上就是一个字节数组，只不过是在这个字节数组上绑定了一些`API`方法方便操作。

## 4.1 From

从无符号整数创建一个`VarInt`类型：

```go

```

## 4.2 ToUint64 & ToUint

将VarInt转为uint64或者uint类型：

```go

```

## 4.3 Divide & Multi & Sub & Add

VarInt类型之间进行加减乘除操作：

```go

```

## 4.4 LessThanOrEqual & LessThan & GreatThanOrEquals & GreatThan



## 4.5 Equals



## 4.6 更多

需要更多类型的操作的话自己把`VarInt`类型转为`uint64`类型然后进行其他计算就可以了，计算完之后再转为`VarInt`存储。







